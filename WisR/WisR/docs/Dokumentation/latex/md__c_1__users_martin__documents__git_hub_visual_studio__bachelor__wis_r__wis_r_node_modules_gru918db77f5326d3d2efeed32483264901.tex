A querystring parsing and stringifying library with some added security.

\href{http://travis-ci.org/hapijs/qs}{\tt !\mbox{[}Build Status\mbox{]}(https\+://secure.\+travis-\/ci.\+org/hapijs/qs.\+svg)}

Lead Maintainer\+: \href{https://github.com/nlf}{\tt Nathan La\+Freniere}

The {\bfseries qs} module was originally created and maintained by \href{https://github.com/visionmedia/node-querystring}{\tt T\+J Holowaychuk}.

\subsection*{Usage}


\begin{DoxyCode}
1 var Qs = require('qs');
2 
3 var obj = Qs.parse('a=c');    // \{ a: 'c' \}
4 var str = Qs.stringify(obj);  // 'a=c'
\end{DoxyCode}


\subsubsection*{Parsing Objects}


\begin{DoxyCode}
1 Qs.parse(string, [depth], [delimiter]);
\end{DoxyCode}


{\bfseries qs} allows you to create nested objects within your query strings, by surrounding the name of sub-\/keys with square brackets {\ttfamily \mbox{[}\mbox{]}}. For example, the string {\ttfamily \textquotesingle{}foo\mbox{[}bar\mbox{]}=baz\textquotesingle{}} converts to\+:


\begin{DoxyCode}
1 \{
2   foo: \{
3     bar: 'baz'
4   \}
5 \}
\end{DoxyCode}


U\+R\+I encoded strings work too\+:


\begin{DoxyCode}
1 Qs.parse('a%5Bb%5D=c');
2 // \{ a: \{ b: 'c' \} \}
\end{DoxyCode}


You can also nest your objects, like {\ttfamily \textquotesingle{}foo\mbox{[}bar\mbox{]}\mbox{[}baz\mbox{]}=foobarbaz\textquotesingle{}}\+:


\begin{DoxyCode}
1 \{
2   foo: \{
3     bar: \{
4       baz: 'foobarbaz'
5     \}
6   \}
7 \}
\end{DoxyCode}


By default, when nesting objects {\bfseries qs} will only parse up to 5 children deep. This means if you attempt to parse a string like {\ttfamily \textquotesingle{}a\mbox{[}b\mbox{]}\mbox{[}c\mbox{]}\mbox{[}d\mbox{]}\mbox{[}e\mbox{]}\mbox{[}f\mbox{]}\mbox{[}g\mbox{]}\mbox{[}h\mbox{]}\mbox{[}i\mbox{]}=j\textquotesingle{}} your resulting object will be\+:


\begin{DoxyCode}
1 \{
2   a: \{
3     b: \{
4       c: \{
5         d: \{
6           e: \{
7             f: \{
8               '[g][h][i]': 'j'
9             \}
10           \}
11         \}
12       \}
13     \}
14   \}
15 \}
\end{DoxyCode}


This depth can be overridden by passing a {\ttfamily depth} option to {\ttfamily Qs.\+parse(string, depth)}\+:


\begin{DoxyCode}
1 Qs.parse('a[b][c][d][e][f][g][h][i]=j', 1);
2 // \{ a: \{ b: \{ '[c][d][e][f][g][h][i]': 'j' \} \} \}
\end{DoxyCode}


The depth limit mitigate abuse when {\bfseries qs} is used to parse user input, and it is recommended to keep it a reasonably small number.

An optional delimiter can also be passed\+:


\begin{DoxyCode}
1 Qs.parse('a=b;c=d', ';');
2 // \{ a: 'b', c: 'd' \}
\end{DoxyCode}


\subsubsection*{Parsing Arrays}

{\bfseries qs} can also parse arrays using a similar {\ttfamily \mbox{[}\mbox{]}} notation\+:


\begin{DoxyCode}
1 Qs.parse('a[]=b&a[]=c');
2 // \{ a: ['b', 'c'] \}
\end{DoxyCode}


You may specify an index as well\+:


\begin{DoxyCode}
1 Qs.parse('a[1]=c&a[0]=b');
2 // \{ a: ['b', 'c'] \}
\end{DoxyCode}


Note that the only difference between an index in an array and a key in an object is that the value between the brackets must be a number to create an array. When creating arrays with specific indices, {\bfseries qs} will compact a sparse array to only the existing values preserving their order\+:


\begin{DoxyCode}
1 Qs.parse('a[1]=b&a[15]=c');
2 // \{ a: ['b', 'c'] \}
\end{DoxyCode}


Note that an empty string is also a value, and will be preserved\+:


\begin{DoxyCode}
1 Qs.parse('a[]=&a[]=b');
2 // \{ a: ['', 'b'] \}
3 Qs.parse('a[0]=b&a[1]=&a[2]=c');
4 // \{ a: ['b', '', 'c'] \}
\end{DoxyCode}


{\bfseries qs} will also limit specifying indices in an array to a maximum index of {\ttfamily 20}. Any array members with an index of greater than {\ttfamily 20} will instead be converted to an object with the index as the key\+:


\begin{DoxyCode}
1 Qs.parse('a[100]=b');
2 // \{ a: \{ '100': 'b' \} \}
\end{DoxyCode}


If you mix notations, {\bfseries qs} will merge the two items into an object\+:


\begin{DoxyCode}
1 Qs.parse('a[0]=b&a[b]=c');
2 // \{ a: \{ '0': 'b', b: 'c' \} \}
\end{DoxyCode}


You can also create arrays of objects\+:


\begin{DoxyCode}
1 Qs.parse('a[][b]=c');
2 // \{ a: [\{ b: 'c' \}] \}
\end{DoxyCode}


\subsubsection*{Stringifying}


\begin{DoxyCode}
1 Qs.stringify(object, [delimiter]);
\end{DoxyCode}


When stringifying, {\bfseries qs} always U\+R\+I encodes output. Objects are stringified as you would expect\+:


\begin{DoxyCode}
1 Qs.stringify(\{ a: 'b' \});
2 // 'a=b'
3 Qs.stringify(\{ a: \{ b: 'c' \} \});
4 // 'a%5Bb%5D=c'
\end{DoxyCode}


Examples beyond this point will be shown as though the output is not U\+R\+I encoded for clarity. Please note that the return values in these cases {\itshape will} be U\+R\+I encoded during real usage.

When arrays are stringified, they are always given explicit indices\+:


\begin{DoxyCode}
1 Qs.stringify(\{ a: ['b', 'c', 'd'] \});
2 // 'a[0]=b&a[1]=c&a[2]=d'
\end{DoxyCode}


Empty strings and null values will omit the value, but the equals sign (=) remains in place\+:


\begin{DoxyCode}
1 Qs.stringify(\{ a: '' \});
2 // 'a='
\end{DoxyCode}


Properties that are set to {\ttfamily undefined} will be omitted entirely\+:


\begin{DoxyCode}
1 Qs.stringify(\{ a: null, b: undefined \});
2 // 'a='
\end{DoxyCode}


The delimiter may be overridden with stringify as well\+:


\begin{DoxyCode}
1 Qs.stringify(\{ a: 'b', c: 'd' \}, ';');
2 // 'a=b;c=d'
\end{DoxyCode}
 