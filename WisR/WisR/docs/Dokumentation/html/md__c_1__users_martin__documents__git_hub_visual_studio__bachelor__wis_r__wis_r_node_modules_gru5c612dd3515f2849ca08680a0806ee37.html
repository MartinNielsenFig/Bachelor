<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>WisR web applikation: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WisR web applikation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://tools.ietf.org/html/rfc6265">RFC6265</a> Cookies and CookieJar for Node.js</p>
<p><a href="https://travis-ci.org/SalesforceEng/tough-cookie">![Build Status](https://travis-ci.org/SalesforceEng/tough-cookie.png?branch=master)</a></p>
<p><a href="https://npmjs.org/package/tough-cookie">![NPM Stats](https://nodei.co/npm/tough-cookie.png?downloads=true&amp;stars=true)</a> </p><div class="image">
<img src="https://nodei.co/npm-dl/tough-cookie.png?months=9"  alt="NPM Downloads"/>
</div>
<h1>Synopsis</h1>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;var tough = require(&#39;tough-cookie&#39;);</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;var Cookie = tough.Cookie;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;var cookie = Cookie.parse(header);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;cookie.value = &#39;somethingdifferent&#39;;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;header = cookie.toString();</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;var cookiejar = new tough.CookieJar();</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;cookiejar.setCookie(cookie, &#39;http://currentdomain.example.com/path&#39;, cb);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;// ...</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;cookiejar.getCookies(&#39;http://example.com/otherpath&#39;,function(err,cookies) {</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  res.headers[&#39;cookie&#39;] = cookies.join(&#39;; &#39;);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;});</div>
</div><!-- fragment --><h1>Installation</h1>
<p>It's <em>so</em> easy!</p>
<p><code>npm install tough-cookie</code></p>
<p>Why the name? NPM modules <code>cookie</code>, <code>cookies</code> and <code>cookiejar</code> were already taken.</p>
<h1>API</h1>
<h2>tough</h2>
<p>Functions on the module you get from `require('tough-cookie')`. All can be used as pure functions and don't need to be "bound".</p>
<p><b>Note</b>: prior to 1.0.x, several of these functions took a <code>strict</code> parameter. This has since been removed from the API as it was no longer necessary.</p>
<h3><code>parseDate(string)</code></h3>
<p>Parse a cookie date string into a <code>Date</code>. Parses according to RFC6265 Section 5.1.1, not <code>Date.parse()</code>.</p>
<h3><code>formatDate(date)</code></h3>
<p>Format a Date into a RFC1123 string (the RFC6265-recommended format).</p>
<h3><code>canonicalDomain(str)</code></h3>
<p>Transforms a domain-name into a canonical domain-name. The canonical domain-name is a trimmed, lowercased, stripped-of-leading-dot and optionally punycode-encoded domain-name (Section 5.1.2 of RFC6265). For the most part, this function is idempotent (can be run again on its output without ill effects).</p>
<h3><code>domainMatch(str,domStr[,canonicalize=true])</code></h3>
<p>Answers "does this real domain match the domain in a cookie?". The <code>str</code> is the "current" domain-name and the <code>domStr</code> is the "cookie" domain-name. Matches according to RFC6265 Section 5.1.3, but it helps to think of it as a "suffix match".</p>
<p>The <code>canonicalize</code> parameter will run the other two paramters through <code>canonicalDomain</code> or not.</p>
<h3><code>defaultPath(path)</code></h3>
<p>Given a current request/response path, gives the Path apropriate for storing in a cookie. This is basically the "directory" of a "file" in the path, but is specified by Section 5.1.4 of the RFC.</p>
<p>The <code>path</code> parameter MUST be <em>only</em> the pathname part of a URI (i.e. excludes the hostname, query, fragment, etc.). This is the <code>.pathname</code> property of node's <code>uri.parse()</code> output.</p>
<h3><code>pathMatch(reqPath,cookiePath)</code></h3>
<p>Answers "does the request-path path-match a given cookie-path?" as per RFC6265 Section 5.1.4. Returns a boolean.</p>
<p>This is essentially a prefix-match where <code>cookiePath</code> is a prefix of <code>reqPath</code>.</p>
<h3><code>parse(cookieString[, options])</code></h3>
<p>alias for <code>Cookie.parse(cookieString[, options])</code></p>
<h3><code>fromJSON(string)</code></h3>
<p>alias for <code>Cookie.fromJSON(string)</code></p>
<h3><code>getPublicSuffix(hostname)</code></h3>
<p>Returns the public suffix of this hostname. The public suffix is the shortest domain-name upon which a cookie can be set. Returns <code>null</code> if the hostname cannot have cookies set for it.</p>
<p>For example: <code>www.example.com</code> and <code>www.subdomain.example.com</code> both have public suffix <code>example.com</code>.</p>
<p>For further information, see <a href="http://publicsuffix.org/">http://publicsuffix.org/</a>. This module derives its list from that site.</p>
<h3><code>cookieCompare(a,b)</code></h3>
<p>For use with <code>.sort()</code>, sorts a list of cookies into the recommended order given in the RFC (Section 5.4 step 2). The sort algorithm is, in order of precedence:</p>
<ul>
<li>Longest <code>.path</code></li>
<li>oldest <code>.creation</code> (which has a 1ms precision, same as <code>Date</code>)</li>
<li>lowest <code>.creationIndex</code> (to get beyond the 1ms precision)</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;var cookies = [ /* unsorted array of Cookie objects */ ];</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cookies = cookies.sort(cookieCompare);</div>
</div><!-- fragment --><p><b>Note</b>: Since JavaScript's <code>Date</code> is limited to a 1ms precision, cookies within the same milisecond are entirely possible. This is especially true when using the <code>now</code> option to <code>.setCookie()</code>. The <code>.creationIndex</code> property is a per-process global counter, assigned during construction with <code>new Cookie()</code>. This preserves the spirit of the RFC sorting: older cookies go first. This works great for <code>MemoryCookieStore</code>, since <code>Set-Cookie</code> headers are parsed in order, but may not be so great for distributed systems. Sophisticated <code><a class="el" href="class_store.html">Store</a></code>s may wish to set this to some other <em>logical clock</em> such that if cookies A and B are created in the same millisecond, but cookie A is created before cookie B, then <code>A.creationIndex &lt; B.creationIndex</code>. If you want to alter the global counter, which you probably <em>shouldn't</em> do, it's stored in <code>Cookie.cookiesCreated</code>.</p>
<h3><code>permuteDomain(domain)</code></h3>
<p>Generates a list of all possible domains that <code>domainMatch()</code> the parameter. May be handy for implementing cookie stores.</p>
<h3><code>permutePath(path)</code></h3>
<p>Generates a list of all possible paths that <code>pathMatch()</code> the parameter. May be handy for implementing cookie stores.</p>
<h2>Cookie</h2>
<p>Exported via <code>tough.Cookie</code>.</p>
<h3><code>Cookie.parse(cookieString[, options])</code></h3>
<p>Parses a single Cookie or Set-Cookie HTTP header into a <code>Cookie</code> object. Returns <code>undefined</code> if the string can't be parsed.</p>
<p>The options parameter is not required and currently has only one property:</p>
<ul>
<li><em>loose</em> - boolean - if <code>true</code> enable parsing of key-less cookies like <code>=abc</code> and <code>=</code>, which are not RFC-compliant.</li>
</ul>
<p>If options is not an object, it is ignored, which means you can use <code>Array::map</code> with it.</p>
<p>Here's how to process the Set-Cookie header(s) on a node HTTP/HTTPS response:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;if (res.headers[&#39;set-cookie&#39;] instanceof Array)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  cookies = res.headers[&#39;set-cookie&#39;].map(Cookie.parse);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;else</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  cookies = [Cookie.parse(res.headers[&#39;set-cookie&#39;])];</div>
</div><!-- fragment --><h3>Properties</h3>
<p>Cookie object properties:</p>
<ul>
<li><em>key</em> - string - the name or key of the cookie (default "")</li>
<li><em>value</em> - string - the value of the cookie (default "")</li>
<li><em>expires</em> - <code>Date</code> - if set, the <code>Expires=</code> attribute of the cookie (defaults to the string <code>"Infinity"</code>). See <code>setExpires()</code></li>
<li><em>maxAge</em> - seconds - if set, the <code>Max-Age=</code> attribute <em>in seconds</em> of the cookie. May also be set to strings <code>"Infinity"</code> and <code>"-Infinity"</code> for non-expiry and immediate-expiry, respectively. See <code>setMaxAge()</code></li>
<li><em>domain</em> - string - the <code>Domain=</code> attribute of the cookie</li>
<li><em>path</em> - string - the <code>Path=</code> of the cookie</li>
<li><em>secure</em> - boolean - the <code>Secure</code> cookie flag</li>
<li><em>httpOnly</em> - boolean - the <code>HttpOnly</code> cookie flag</li>
<li><em>extensions</em> - <code>Array</code> - any unrecognized cookie attributes as strings (even if equal-signs inside)</li>
<li><em>creation</em> - <code>Date</code> - when this cookie was constructed</li>
<li><em>creationIndex</em> - number - set at construction, used to provide greater sort precision (please see <code>cookieCompare(a,b)</code> for a full explanation)</li>
</ul>
<p>After a cookie has been passed through <code>CookieJar.setCookie()</code> it will have the following additional attributes:</p>
<ul>
<li><em>hostOnly</em> - boolean - is this a host-only cookie (i.e. no Domain field was set, but was instead implied)</li>
<li><em>pathIsDefault</em> - boolean - if true, there was no Path field on the cookie and <code>defaultPath()</code> was used to derive one.</li>
<li><em>creation</em> - <code>Date</code> - <b>modified</b> from construction to when the cookie was added to the jar</li>
<li><em>lastAccessed</em> - <code>Date</code> - last time the cookie got accessed. Will affect cookie cleaning once implemented. Using <code>cookiejar.getCookies(...)</code> will update this attribute.</li>
</ul>
<h3><code>Cookie([{properties}])</code></h3>
<p>Receives an options object that can contain any of the above Cookie properties, uses the default for unspecified properties.</p>
<h3><code>.toString()</code></h3>
<p>encode to a Set-Cookie header value. The Expires cookie field is set using <code>formatDate()</code>, but is omitted entirely if <code>.expires</code> is <code>Infinity</code>.</p>
<h3><code>.cookieString()</code></h3>
<p>encode to a Cookie header value (i.e. the <code>.key</code> and <code>.value</code> properties joined with '=').</p>
<h3><code>.setExpires(String)</code></h3>
<p>sets the expiry based on a date-string passed through <code>parseDate()</code>. If parseDate returns <code>null</code> (i.e. can't parse this date string), <code>.expires</code> is set to <code>"Infinity"</code> (a string) is set.</p>
<h3><code>.setMaxAge(number)</code></h3>
<p>sets the maxAge in seconds. Coerces <code>-Infinity</code> to <code>"-Infinity"</code> and <code>Infinity</code> to <code>"Infinity"</code> so it JSON serializes correctly.</p>
<h3><code>.expiryTime([now=Date.now()])</code></h3>
<h3><code>.expiryDate([now=Date.now()])</code></h3>
<p>expiryTime() Computes the absolute unix-epoch milliseconds that this cookie expires. expiryDate() works similarly, except it returns a <code>Date</code> object. Note that in both cases the <code>now</code> parameter should be milliseconds.</p>
<p>Max-Age takes precedence over Expires (as per the RFC). The <code>.creation</code> attribute &ndash; or, by default, the <code>now</code> paramter &ndash; is used to offset the <code>.maxAge</code> attribute.</p>
<p>If Expires (<code>.expires</code>) is set, that's returned.</p>
<p>Otherwise, <code>expiryTime()</code> returns <code>Infinity</code> and <code>expiryDate()</code> returns a <code>Date</code> object for "Tue, 19 Jan 2038 03:14:07 GMT" (latest date that can be expressed by a 32-bit <code>time_t</code>; the common limit for most user-agents).</p>
<h3><code>.TTL([now=Date.now()])</code></h3>
<p>compute the TTL relative to <code>now</code> (milliseconds). The same precedence rules as for <code>expiryTime</code>/<code>expiryDate</code> apply.</p>
<p>The "number" <code>Infinity</code> is returned for cookies without an explicit expiry and <code>0</code> is returned if the cookie is expired. Otherwise a time-to-live in milliseconds is returned.</p>
<h3><code>.canonicalizedDoman()</code></h3>
<h3><code>.cdomain()</code></h3>
<p>return the canonicalized <code>.domain</code> field. This is lower-cased and punycode (RFC3490) encoded if the domain has any non-ASCII characters.</p>
<h3><code>.toJSON()</code></h3>
<p>For convenience in using <code>JSON.serialize(cookie)</code>. Returns a plain-old <code>Object</code> that can be JSON-serialized.</p>
<p>Any <code>Date</code> properties (i.e., <code>.expires</code>, <code>.creation</code>, and <code>.lastAccessed</code>) are exported in ISO format (<code>.toISOString()</code>).</p>
<p><b>NOTE</b>: Custom <code>Cookie</code> properties will be discarded. In tough-cookie 1.x, since there was no <code>.toJSON</code> method explicitly defined, all enumerable properties were captured. If you want a property to be serialized, add the property name to the <code>Cookie.serializableProperties</code> Array.</p>
<h3><code>Cookie.fromJSON(strOrObj)</code></h3>
<p>Does the reverse of <code>cookie.toJSON()</code>. If passed a string, will <code>JSON.parse()</code> that first.</p>
<p>Any <code>Date</code> properties (i.e., <code>.expires</code>, <code>.creation</code>, and <code>.lastAccessed</code>) are parsed via <code>Date.parse()</code>, not the tough-cookie <code>parseDate</code>, since it's JavaScript/JSON-y timestamps being handled at this layer.</p>
<p>Returns <code>null</code> upon JSON parsing error.</p>
<h3><code>.clone()</code></h3>
<p>Does a deep clone of this cookie, exactly implemented as <code>Cookie.fromJSON(cookie.toJSON())</code>.</p>
<h3><code>.validate()</code></h3>
<p>Status: <em>IN PROGRESS</em>. Works for a few things, but is by no means comprehensive.</p>
<p>validates cookie attributes for semantic correctness. Useful for "lint" checking any Set-Cookie headers you generate. For now, it returns a boolean, but eventually could return a reason string &ndash; you can future-proof with this construct:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;if (cookie.validate() === true) {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  // it&#39;s tasty</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;} else {</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  // yuck!</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div>
</div><!-- fragment --><h2>CookieJar</h2>
<p>Exported via <code>tough.CookieJar</code>.</p>
<h3><code>CookieJar([store],[rejectPublicSuffixes])</code></h3>
<p>Simply use <code>new CookieJar()</code>. If you'd like to use a custom store, pass that to the constructor otherwise a <code>MemoryCookieStore</code> will be created and used.</p>
<h3>Properties</h3>
<p>CookieJar object properties:</p>
<ul>
<li><em>rejectPublicSuffixes</em> - boolean - reject cookies with domains like "com" and "co.uk" (default: <code>true</code>)</li>
</ul>
<p>Since eventually this module would like to support database/remote/etc. CookieJars, continuation passing style is used for CookieJar methods.</p>
<h3><code>.setCookie(cookieOrString, currentUrl, [{options},] cb(err,cookie))</code></h3>
<p>Attempt to set the cookie in the cookie jar. If the operation fails, an error will be given to the callback <code>cb</code>, otherwise the cookie is passed through. The cookie will have updated <code>.creation</code>, <code>.lastAccessed</code> and <code>.hostOnly</code> properties.</p>
<p>The <code>options</code> object can be omitted and can have the following properties:</p>
<ul>
<li><em>http</em> - boolean - default <code>true</code> - indicates if this is an HTTP or non-HTTP API. Affects HttpOnly cookies.</li>
<li><em>secure</em> - boolean - autodetect from url - indicates if this is a "Secure" API. If the currentUrl starts with <code>https:</code> or <code>wss:</code> then this is defaulted to <code>true</code>, otherwise <code>false</code>.</li>
<li><em>now</em> - Date - default <code>new Date()</code> - what to use for the creation/access time of cookies</li>
<li><em>ignoreError</em> - boolean - default <code>false</code> - silently ignore things like parse errors and invalid domains. <code><a class="el" href="class_store.html">Store</a></code> errors aren't ignored by this option.</li>
</ul>
<p>As per the RFC, the <code>.hostOnly</code> property is set if there was no "Domain=" parameter in the cookie string (or <code>.domain</code> was null on the Cookie object). The <code>.domain</code> property is set to the fully-qualified hostname of <code>currentUrl</code> in this case. Matching this cookie requires an exact hostname match (not a <code>domainMatch</code> as per usual).</p>
<h3><code>.setCookieSync(cookieOrString, currentUrl, [{options}])</code></h3>
<p>Synchronous version of <code>setCookie</code>; only works with synchronous stores (e.g. the default <code>MemoryCookieStore</code>).</p>
<h3><code>.getCookies(currentUrl, [{options},] cb(err,cookies))</code></h3>
<p>Retrieve the list of cookies that can be sent in a Cookie header for the current url.</p>
<p>If an error is encountered, that's passed as <code>err</code> to the callback, otherwise an <code>Array</code> of <code>Cookie</code> objects is passed. The array is sorted with <code>cookieCompare()</code> unless the <code>{sort:false}</code> option is given.</p>
<p>The <code>options</code> object can be omitted and can have the following properties:</p>
<ul>
<li><em>http</em> - boolean - default <code>true</code> - indicates if this is an HTTP or non-HTTP API. Affects HttpOnly cookies.</li>
<li><em>secure</em> - boolean - autodetect from url - indicates if this is a "Secure" API. If the currentUrl starts with <code>https:</code> or <code>wss:</code> then this is defaulted to <code>true</code>, otherwise <code>false</code>.</li>
<li><em>now</em> - Date - default <code>new Date()</code> - what to use for the creation/access time of cookies</li>
<li><em>expire</em> - boolean - default <code>true</code> - perform expiry-time checking of cookies and asynchronously remove expired cookies from the store. Using <code>false</code> will return expired cookies and <b>not</b> remove them from the store (which is useful for replaying Set-Cookie headers, potentially).</li>
<li><em>allPaths</em> - boolean - default <code>false</code> - if <code>true</code>, do not scope cookies by path. The default uses RFC-compliant path scoping. <b>Note</b>: may not be supported by the underlying store (the default <code>MemoryCookieStore</code> supports it).</li>
</ul>
<p>The <code>.lastAccessed</code> property of the returned cookies will have been updated.</p>
<h3><code>.getCookiesSync(currentUrl, [{options}])</code></h3>
<p>Synchronous version of <code>getCookies</code>; only works with synchronous stores (e.g. the default <code>MemoryCookieStore</code>).</p>
<h3><code>.getCookieString(...)</code></h3>
<p>Accepts the same options as <code>.getCookies()</code> but passes a string suitable for a Cookie header rather than an array to the callback. Simply maps the <code>Cookie</code> array via <code>.cookieString()</code>.</p>
<h3><code>.getCookieStringSync(...)</code></h3>
<p>Synchronous version of <code>getCookieString</code>; only works with synchronous stores (e.g. the default <code>MemoryCookieStore</code>).</p>
<h3><code>.getSetCookieStrings(...)</code></h3>
<p>Returns an array of strings suitable for <b>Set-Cookie</b> headers. Accepts the same options as <code>.getCookies()</code>. Simply maps the cookie array via <code>.toString()</code>.</p>
<h3><code>.getSetCookieStringsSync(...)</code></h3>
<p>Synchronous version of <code>getSetCookieStrings</code>; only works with synchronous stores (e.g. the default <code>MemoryCookieStore</code>).</p>
<h3><code>.serialize(cb(err,serializedObject))</code></h3>
<p>Serialize the Jar if the underlying store supports <code>.getAllCookies</code>.</p>
<p><b>NOTE</b>: Custom <code>Cookie</code> properties will be discarded. If you want a property to be serialized, add the property name to the <code>Cookie.serializableProperties</code> Array.</p>
<p>See [Serialization Format].</p>
<h3><code>.serializeSync()</code></h3>
<p>Sync version of .serialize</p>
<h3><code>.toJSON()</code></h3>
<p>Alias of .serializeSync() for the convenience of <code>JSON.stringify(cookiejar)</code>.</p>
<h3><code>CookieJar.deserialize(serialized, [store], cb(err,object))</code></h3>
<p>A new Jar is created and the serialized Cookies are added to the underlying store. Each <code>Cookie</code> is added via <code>store.putCookie</code> in the order in which they appear in the serialization.</p>
<p>The <code>store</code> argument is optional, but should be an instance of <code><a class="el" href="class_store.html">Store</a></code>. By default, a new instance of <code>MemoryCookieStore</code> is created.</p>
<p>As a convenience, if <code>serialized</code> is a string, it is passed through <code>JSON.parse</code> first. If that throws an error, this is passed to the callback.</p>
<h3><code>CookieJar.deserializeSync(serialized, [store])</code></h3>
<p>Sync version of <code>.deserialize</code>. <em>Note</em> that the <code>store</code> must be synchronous for this to work.</p>
<h3><code>CookieJar.fromJSON(string)</code></h3>
<p>Alias of <code>.deserializeSync</code> to provide consistency with <code>Cookie.fromJSON()</code>.</p>
<h3><code>.clone([store,]cb(err,newJar))</code></h3>
<p>Produces a deep clone of this jar. Modifications to the original won't affect the clone, and vice versa.</p>
<p>The <code>store</code> argument is optional, but should be an instance of <code><a class="el" href="class_store.html">Store</a></code>. By default, a new instance of <code>MemoryCookieStore</code> is created. Transferring between store types is supported so long as the source implements <code>.getAllCookies()</code> and the destination implements <code>.putCookie()</code>.</p>
<h3><code>.cloneSync([store])</code></h3>
<p>Synchronous version of <code>.clone</code>, returning a new <code>CookieJar</code> instance.</p>
<p>The <code>store</code> argument is optional, but must be a <em>synchronous</em> <code><a class="el" href="class_store.html">Store</a></code> instance if specified. If not passed, a new instance of <code>MemoryCookieStore</code> is used.</p>
<p>The <em>source</em> and <em>destination</em> must both be synchronous <code><a class="el" href="class_store.html">Store</a></code>s. If one or both stores are asynchronous, use <code>.clone</code> instead. Recall that <code>MemoryCookieStore</code> supports both synchronous and asynchronous API calls.</p>
<h2><a class="el" href="class_store.html">Store</a></h2>
<p>Base class for CookieJar stores. Available as <code>tough.Store</code>.</p>
<h2><a class="el" href="class_store.html">Store</a> API</h2>
<p>The storage model for each <code>CookieJar</code> instance can be replaced with a custom implementation. The default is <code>MemoryCookieStore</code> which can be found in the <code>lib/memstore.js</code> file. The API uses continuation-passing-style to allow for asynchronous stores.</p>
<p>Stores should inherit from the base <code><a class="el" href="class_store.html">Store</a></code> class, which is available as `require('tough-cookie').Store`.</p>
<p>Stores are asynchronous by default, but if <code>store.synchronous</code> is set to <code>true</code>, then the <code>*Sync</code> methods on the of the containing <code>CookieJar</code> can be used (however, the continuation-passing style</p>
<p>All <code>domain</code> parameters will have been normalized before calling.</p>
<p>The Cookie store must have all of the following methods.</p>
<h3><code>store.findCookie(domain, path, key, cb(err,cookie))</code></h3>
<p>Retrieve a cookie with the given domain, path and key (a.k.a. name). The RFC maintains that exactly one of these cookies should exist in a store. If the store is using versioning, this means that the latest/newest such cookie should be returned.</p>
<p>Callback takes an error and the resulting <code>Cookie</code> object. If no cookie is found then <code>null</code> MUST be passed instead (i.e. not an error).</p>
<h3><code>store.findCookies(domain, path, cb(err,cookies))</code></h3>
<p>Locates cookies matching the given domain and path. This is most often called in the context of <code>cookiejar.getCookies()</code> above.</p>
<p>If no cookies are found, the callback MUST be passed an empty array.</p>
<p>The resulting list will be checked for applicability to the current request according to the RFC (domain-match, path-match, http-only-flag, secure-flag, expiry, etc.), so it's OK to use an optimistic search algorithm when implementing this method. However, the search algorithm used SHOULD try to find cookies that <code>domainMatch()</code> the domain and <code>pathMatch()</code> the path in order to limit the amount of checking that needs to be done.</p>
<p>As of version 0.9.12, the <code>allPaths</code> option to <code>cookiejar.getCookies()</code> above will cause the path here to be <code>null</code>. If the path is <code>null</code>, path-matching MUST NOT be performed (i.e. domain-matching only).</p>
<h3><code>store.putCookie(cookie, cb(err))</code></h3>
<p>Adds a new cookie to the store. The implementation SHOULD replace any existing cookie with the same <code>.domain</code>, <code>.path</code>, and <code>.key</code> properties &ndash; depending on the nature of the implementation, it's possible that between the call to <code>fetchCookie</code> and <code>putCookie</code> that a duplicate <code>putCookie</code> can occur.</p>
<p>The <code>cookie</code> object MUST NOT be modified; the caller will have already updated the <code>.creation</code> and <code>.lastAccessed</code> properties.</p>
<p>Pass an error if the cookie cannot be stored.</p>
<h3><code>store.updateCookie(oldCookie, newCookie, cb(err))</code></h3>
<p>Update an existing cookie. The implementation MUST update the <code>.value</code> for a cookie with the same <code>domain</code>, <code>.path</code> and <code>.key</code>. The implementation SHOULD check that the old value in the store is equivalent to <code>oldCookie</code> - how the conflict is resolved is up to the store.</p>
<p>The <code>.lastAccessed</code> property will always be different between the two objects (to the precision possible via JavaScript's clock). Both <code>.creation</code> and <code>.creationIndex</code> are guaranteed to be the same. Stores MAY ignore or defer the <code>.lastAccessed</code> change at the cost of affecting how cookies are selected for automatic deletion (e.g., least-recently-used, which is up to the store to implement).</p>
<p>Stores may wish to optimize changing the <code>.value</code> of the cookie in the store versus storing a new cookie. If the implementation doesn't define this method a stub that calls <code>putCookie(newCookie,cb)</code> will be added to the store object.</p>
<p>The <code>newCookie</code> and <code>oldCookie</code> objects MUST NOT be modified.</p>
<p>Pass an error if the newCookie cannot be stored.</p>
<h3><code>store.removeCookie(domain, path, key, cb(err))</code></h3>
<p>Remove a cookie from the store (see notes on <code>findCookie</code> about the uniqueness constraint).</p>
<p>The implementation MUST NOT pass an error if the cookie doesn't exist; only pass an error due to the failure to remove an existing cookie.</p>
<h3><code>store.removeCookies(domain, path, cb(err))</code></h3>
<p>Removes matching cookies from the store. The <code>path</code> parameter is optional, and if missing means all paths in a domain should be removed.</p>
<p>Pass an error ONLY if removing any existing cookies failed.</p>
<h3><code>store.getAllCookies(cb(err, cookies))</code></h3>
<p>Produces an <code>Array</code> of all cookies during <code>jar.serialize()</code>. The items in the array can be true <code>Cookie</code> objects or generic <code>Object</code>s with the [Serialization Format] data structure.</p>
<p>Cookies SHOULD be returned in creation order to preserve sorting via <code>compareCookies()</code>. For reference, <code>MemoryCookieStore</code> will sort by <code>.creationIndex</code> since it uses true <code>Cookie</code> objects internally. If you don't return the cookies in creation order, they'll still be sorted by creation time, but this only has a precision of 1ms. See <code>compareCookies</code> for more detail.</p>
<p>Pass an error if retrieval fails.</p>
<h2>MemoryCookieStore</h2>
<p>Inherits from <code><a class="el" href="class_store.html">Store</a></code>.</p>
<p>A just-in-memory CookieJar synchronous store implementation, used by default. Despite being a synchronous implementation, it's usable with both the synchronous and asynchronous forms of the <code>CookieJar</code> API.</p>
<h1>Serialization Format</h1>
<p><b>NOTE</b>: if you want to have custom <code>Cookie</code> properties serialized, add the property name to <code>Cookie.serializableProperties</code>.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  <span class="comment">// The version of tough-cookie that serialized this jar.</span></div>
<div class="line">  version: <span class="stringliteral">&#39;tough-cookie@1.x.y&#39;</span>,</div>
<div class="line"></div>
<div class="line">  <span class="comment">// add the store type, to make humans happy:</span></div>
<div class="line">  storeType: <span class="stringliteral">&#39;MemoryCookieStore&#39;</span>,</div>
<div class="line"></div>
<div class="line">  <span class="comment">// CookieJar configuration:</span></div>
<div class="line">  rejectPublicSuffixes: <span class="keyword">true</span>,</div>
<div class="line">  <span class="comment">// ... future items go here</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Gets filled from jar.store.getAllCookies():</span></div>
<div class="line">  cookies: [</div>
<div class="line">    {</div>
<div class="line">      key: <span class="stringliteral">&#39;string&#39;</span>,</div>
<div class="line">      value: <span class="stringliteral">&#39;string&#39;</span>,</div>
<div class="line">      <span class="comment">// ...</span></div>
<div class="line">      <span class="comment">/* other Cookie.serializableProperties go here */</span></div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><h1>Copyright and License</h1>
<p>(tl;dr: BSD-3-Clause with some MPL/2.0)</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Copyright (c) 2015, Salesforce.com, Inc.</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;All rights reserved.</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;Redistribution and use in source and binary forms, with or without</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;modification, are permitted provided that the following conditions are met:</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;1. Redistributions of source code must retain the above copyright notice,</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;this list of conditions and the following disclaimer.</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;2. Redistributions in binary form must reproduce the above copyright notice,</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;this list of conditions and the following disclaimer in the documentation</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;and/or other materials provided with the distribution.</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;3. Neither the name of Salesforce.com nor the names of its contributors may</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;be used to endorse or promote products derived from this software without</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;specific prior written permission.</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;POSSIBILITY OF SUCH DAMAGE.</div>
</div><!-- fragment --><p>Portions may be licensed under different licenses (in particular <code>public_suffix_list.dat</code> is MPL/2.0); please read that file and the LICENSE file for full details. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
